# mcp/node_scorer.py\n\nimport statistics\nimport math\nfrom .heuristic import Heuristic # Assuming heuristic.py is in the same directory (mcp)\n\n# Define a helper structure or rely on dicts for config/node data\n# For clarity, let\'s assume config is a dict like the one discussed previously.\n\nclass NodeScorer:\n    """\n    Calculates a composite score for Lightning Network nodes based on multiple\n    weighted heuristics. Inspired by the approach in Hydrus.\n    """\n    def __init__(self, open_weights_config: dict):\n        """\n        Initializes the NodeScorer with a specific weighting configuration.\n\n        Args:\n            open_weights_config: A dictionary defining the weights for each heuristic.\n                                 Expected structure:\n                                 {\n                                     "capacity": float,\n                                     "features": float,\n                                     "hybrid": float,\n                                     "centrality": {\n                                         "degree": float,\n                                         "betweenness": float,\n                                         "closeness": float,\n                                         "eigenvector": float,\n                                     },\n                                     "channels": {\n                                         "base_fee": float,\n                                         "fee_rate": float,\n                                         # "inbound_base_fee": float, # Optional\n                                         # "inbound_fee_rate": float, # Optional\n                                         "min_htlc": float,\n                                         "max_htlc": float,\n                                         "age": float, # Expects age in blocks/days (higher better)\n                                     }\n                                 }\n        """\n        self.weights = open_weights_config # Store weights if needed later\n\n        # --- Initialize Node-Level Heuristics ---\n        self.h_capacity = Heuristic(\n            weight=open_weights_config.get("capacity", 0.0),\n            lower_is_better=False # Higher capacity is better\n        )\n        self.h_features = Heuristic(\n            weight=open_weights_config.get("features", 0.0),\n            lower_is_better=False # More features generally better (simple count)\n        )\n        # Hybrid is binary (0 or 1), preset range\n        self.h_hybrid = Heuristic(\n            weight=open_weights_config.get("hybrid", 0.0),\n            lower_is_better=False, # 1 (hybrid) is better than 0\n            initial_lowest=0.0,\n            initial_highest=1.0\n        )\n\n        # --- Initialize Centrality Heuristics ---\n        centrality_weights = open_weights_config.get("centrality", {})\n        self.h_degree = Heuristic(\n            weight=centrality_weights.get("degree", 0.0),\n            lower_is_better=False # Higher normalized degree is better\n        )\n        self.h_betweenness = Heuristic(\n            weight=centrality_weights.get("betweenness", 0.0),\n            lower_is_better=False # Higher betweenness is better\n        )\n         # Closeness: If using (N-1)/sum_dist, higher is better.\n         # If using sum_dist directly, lower is better.\n         # Assuming the former based on hydrus calculation shown.\n        self.h_closeness = Heuristic(\n            weight=centrality_weights.get("closeness", 0.0),\n            lower_is_better=False\n        )\n        self.h_eigenvector = Heuristic(\n            weight=centrality_weights.get("eigenvector", 0.0),\n            lower_is_better=False # Higher eigenvector centrality is better\n        )\n\n        # --- Initialize Channel-Level Heuristics (for averages) ---\n        channel_weights = open_weights_config.get("channels", {})\n        self.h_channel_base_fee = Heuristic(\n            weight=channel_weights.get("base_fee", 0.0),\n            lower_is_better=True # Lower base fee is better\n        )\n        self.h_channel_fee_rate = Heuristic(\n            weight=channel_weights.get("fee_rate", 0.0),\n            lower_is_better=True # Lower fee rate is better\n        )\n        # Add inbound if needed and available from LNBits\n        # self.h_channel_inbound_base_fee = Heuristic(...)\n        # self.h_channel_inbound_fee_rate = Heuristic(...)\n        self.h_channel_min_htlc = Heuristic(\n            weight=channel_weights.get("min_htlc", 0.0),\n            lower_is_better=True # Lower min_htlc allows smaller payments\n        )\n        self.h_channel_max_htlc = Heuristic(\n            weight=channel_weights.get("max_htlc", 0.0),\n            lower_is_better=False # Higher max_htlc allows larger payments\n        )\n        self.h_channel_age = Heuristic(\n            weight=channel_weights.get("age", 0.0),\n            lower_is_better=False # Higher age (older channel) is generally better\n        )\n\n        # Store all heuristics for easier iteration\n        self._all_heuristics = [\n            self.h_capacity, self.h_features, self.h_hybrid,\n            self.h_degree, self.h_betweenness, self.h_closeness, self.h_eigenvector,\n            self.h_channel_base_fee, self.h_channel_fee_rate,\n            self.h_channel_min_htlc, self.h_channel_max_htlc, self.h_channel_age\n            # Add inbound fee heuristics here if used\n        ]\n\n    def _calculate_average_channel_metrics(self, node_channels: list) -> dict:\n        """ Calculates average metrics across a node\'s valid channels. """\n        metrics = {\n            "avg_base_fee": None, "avg_fee_rate": None, "avg_min_htlc": None,\n            "avg_max_htlc": None, "avg_age": None\n        }\n        if not node_channels:\n            return metrics # Return None if no channels\n\n        # Extract values, ignoring None entries for robust averaging\n        # Ensure the keys match the actual data structure from LNBits/preprocessing\n        base_fees = [c.get(\'base_fee_msat\') for c in node_channels if c.get(\'base_fee_msat\') is not None]\n        fee_rates = [c.get(\'fee_rate_ppm\') for c in node_channels if c.get(\'fee_rate_ppm\') is not None]\n        min_htlcs = [c.get(\'min_htlc_msat\') for c in node_channels if c.get(\'min_htlc_msat\') is not None]\n        max_htlcs = [c.get(\'max_htlc_msat\') for c in node_channels if c.get(\'max_htlc_msat\') is not None]\n        ages = [c.get(\'age_blocks\') for c in node_channels if c.get(\'age_blocks\') is not None] # Assuming \'age_blocks\' key\n\n        # Calculate means only if data exists for that metric\n        try:\n            if base_fees: metrics["avg_base_fee"] = statistics.mean(base_fees)\n        except statistics.StatisticsError:\n             metrics["avg_base_fee"] = None # Handle potential errors if list is empty after filtering Nones\n        try:\n             if fee_rates: metrics["avg_fee_rate"] = statistics.mean(fee_rates)\n        except statistics.StatisticsError:\n             metrics["avg_fee_rate"] = None\n        try:\n            if min_htlcs: metrics["avg_min_htlc"] = statistics.mean(min_htlcs)\n        except statistics.StatisticsError:\n             metrics["avg_min_htlc"] = None\n        try:\n            if max_htlcs: metrics["avg_max_htlc"] = statistics.mean(max_htlcs)\n        except statistics.StatisticsError:\n            metrics["avg_max_htlc"] = None\n        try:\n            if ages: metrics["avg_age"] = statistics.mean(ages)\n        except statistics.StatisticsError:\n             metrics["avg_age"] = None\n\n\n        return metrics\n\n    def update_ranges(self, all_nodes_data: list):\n        """\n        Updates the min/max ranges for all heuristics based on the provided dataset.\n\n        Args:\n            all_nodes_data: A list of dictionaries, where each dictionary represents\n                            a node and contains its raw metrics (capacity, features,\n                            centrality values, and list of channels). Centrality\n                            and filtering should be done *before* this step.\n        """\n        if not all_nodes_data:\n             print("Warning: No node data provided to update heuristic ranges.")\n             return\n\n        print(f"Updating heuristic ranges based on {len(all_nodes_data)} nodes...")\n        # Reset ranges? No, hydrus accumulates. Assume we want the same.\n\n        for node_data in all_nodes_data:\n            # --- Update Node-Level Heuristics ---\n            self.h_capacity.update(node_data.get(\'capacity_sats\'))\n            self.h_features.update(node_data.get(\'features_count\')) # Assuming key \'features_count\'\n\n            # Calculate hybrid value (0 or 1)\n            addresses = node_data.get(\'addresses\', [])\n            # Refined check for hybrid status, handling potential None/empty strings\n            has_clearnet = False\n            has_tor = False\n            if addresses:\n                 for addr in addresses:\n                      if not isinstance(addr, str) or not addr:\n                           continue\n                      host_part = addr.split(":")[0]\n                      if ".onion" in host_part:\n                           has_tor = True\n                      elif "." in host_part: # Basic check for potentially clearnet (IP or domain)\n                           has_clearnet = True\n                      if has_clearnet and has_tor:\n                           break # Found both\n\n            hybrid_value = 1.0 if has_clearnet and has_tor else 0.0\n            self.h_hybrid.update(hybrid_value) # Update uses the 0 or 1 value\n\n            # Update Centrality Heuristics\n            centrality = node_data.get(\'centrality\', {})\n            self.h_degree.update(centrality.get(\'degree\'))\n            self.h_betweenness.update(centrality.get(\'betweenness\'))\n            self.h_closeness.update(centrality.get(\'closeness\'))\n            self.h_eigenvector.update(centrality.get(\'eigenvector\'))\n\n            # --- Calculate Average Channel Metrics for this node ---\n            avg_chan_metrics = self._calculate_average_channel_metrics(node_data.get(\'channels\', []))\n\n            # --- Update Channel-Level Heuristics (using averages) ---\n            # Only update range if average could be calculated\n            if avg_chan_metrics["avg_base_fee"] is not None:\n                self.h_channel_base_fee.update(avg_chan_metrics["avg_base_fee"])\n            if avg_chan_metrics["avg_fee_rate"] is not None:\n                self.h_channel_fee_rate.update(avg_chan_metrics["avg_fee_rate"])\n            if avg_chan_metrics["avg_min_htlc"] is not None:\n                self.h_channel_min_htlc.update(avg_chan_metrics["avg_min_htlc"])\n            if avg_chan_metrics["avg_max_htlc"] is not None:\n                self.h_channel_max_htlc.update(avg_chan_metrics["avg_max_htlc"])\n            if avg_chan_metrics["avg_age"] is not None:\n                self.h_channel_age.update(avg_chan_metrics["avg_age"])\n\n        print("Heuristic ranges updated.")\n        # Optionally print the updated ranges for debugging\n        # for h in self._all_heuristics: print(repr(h))\n\n\n    def calculate_node_score(self, node_data: dict) -> float:\n        """\n        Calculates the final weighted score for a single node.\n\n        Args:\n            node_data: A dictionary representing the node\'s data, including\n                       pre-calculated centrality and channel list.\n                       Assumes keys like \'capacity_sats\', \'features_count\',\n                       \'centrality\':{\'degree\',...\}, \'channels\':[{...}].\n\n        Returns:\n            The final score for the node (float).\n        """\n        total_score = 0.0\n\n        # --- Score Node-Level Heuristics ---\n        total_score += self.h_capacity.get_score(node_data.get(\'capacity_sats\'))\n        total_score += self.h_features.get_score(node_data.get(\'features_count\'))\n\n        addresses = node_data.get(\'addresses\', [])\n        has_clearnet = False\n        has_tor = False\n        if addresses:\n            for addr in addresses:\n                if not isinstance(addr, str) or not addr:\n                    continue\n                host_part = addr.split(":")[0]\n                if ".onion" in host_part:\n                    has_tor = True\n                elif "." in host_part: # Basic check\n                    has_clearnet = True\n                if has_clearnet and has_tor:\n                    break\n        hybrid_value = 1.0 if has_clearnet and has_tor else 0.0\n        total_score += self.h_hybrid.get_score(hybrid_value)\n\n        # Score Centrality Heuristics\n        centrality = node_data.get(\'centrality\', {})\n        total_score += self.h_degree.get_score(centrality.get(\'degree\'))\n        total_score += self.h_betweenness.get_score(centrality.get(\'betweenness\'))\n        total_score += self.h_closeness.get_score(centrality.get(\'closeness\'))\n        total_score += self.h_eigenvector.get_score(centrality.get(\'eigenvector\'))\n\n        # --- Calculate Average Channel Metrics for this node ---\n        avg_chan_metrics = self._calculate_average_channel_metrics(node_data.get(\'channels\', []))\n\n        # --- Score Channel-Level Heuristics (using averages) ---\n        # Add scores only if the average could be calculated (i.e., node has channels with relevant data)\n        if avg_chan_metrics["avg_base_fee"] is not None:\n             total_score += self.h_channel_base_fee.get_score(avg_chan_metrics["avg_base_fee"])\n        if avg_chan_metrics["avg_fee_rate"] is not None:\n             total_score += self.h_channel_fee_rate.get_score(avg_chan_metrics["avg_fee_rate"])\n        if avg_chan_metrics["avg_min_htlc"] is not None:\n             total_score += self.h_channel_min_htlc.get_score(avg_chan_metrics["avg_min_htlc"])\n        if avg_chan_metrics["avg_max_htlc"] is not None:\n             total_score += self.h_channel_max_htlc.get_score(avg_chan_metrics["avg_max_htlc"])\n        if avg_chan_metrics["avg_age"] is not None:\n             total_score += self.h_channel_age.get_score(avg_chan_metrics["avg_age"])\n\n\n        # Hydrus rounds the score\n        return round(total_score, 3) # Round to 3 decimal places like hydrus 