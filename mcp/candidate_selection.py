# mcp/candidate_selection.py\n\nimport time\nfrom datetime import datetime, timedelta\n\n# --- Configuration Constants ---\n# How far back to look for recent channel closures/failures (in blocks)\nRECENT_CLOSURE_THRESHOLD_BLOCKS = 144 * 30 * 3 # Approx 3 months\n\ndef filter_candidates(\n    scored_candidates: list[dict],\n    local_node_info: dict,\n    blocklist: list[str],\n    current_block_height: int\n) -> list[dict]:\n    """\n    Applies final filtering rules to a list of scored candidate nodes.\n\n    Removes nodes that are:\n    - Explicitly blocklisted.\n    - The node itself.\n    - Already have an active channel with the node.\n    - Had a channel closed with the node recently.\n    - (Optional: Had a failed channel opening attempt recently).\n    - (Optional: Share too many peers).\n\n    Args:\n        scored_candidates: List of node data dictionaries, sorted by score descending.\n                           Each dict must contain at least \'pubkey\' and \'score\'.\n                           It may also contain \'channels\' (list of dicts).\n        local_node_info: Dictionary with info about the local node. Expected keys:\n                         \'pubkey\': str (Our node\'s public key)\n                         \'current_peers\': set[str] (Pubkeys of nodes we have active channels with)\n                         \'recent_closures\': list[dict] (Info on recent closures. Each dict\n                           needs \'remote_pubkey\': str, \'close_height\': int, optionally \'close_type\', \'open_initiator\').\n        blocklist: List of explicitly forbidden node public keys.\n        current_block_height: The current blockchain height.\n\n    Returns:\n        A list of candidate node dictionaries that passed the final filtering.\n    """\n    if not scored_candidates:\n        return []\n\n    print(f"Applying final filters to {len(scored_candidates)} scored candidates...")\n    start_time = time.time()\n    final_candidates = []\n    skipped_blocklist = 0\n    skipped_self = 0\n    skipped_current_peer = 0\n    skipped_recent_closure = 0\n    # skipped_failed_open = 0 # Counter if implemented\n    # skipped_shared_peers = 0 # Counter if implemented\n\n    local_pubkey = local_node_info.get(\'pubkey\')\n    current_peers = local_node_info.get(\'current_peers\', set())\n    recent_closures = local_node_info.get(\'recent_closures\', [])\n    blocklist_set = set(blocklist)\n\n    # Calculate the block height threshold for recent closures\n    closure_cutoff_height = current_block_height - RECENT_CLOSURE_THRESHOLD_BLOCKS if current_block_height > RECENT_CLOSURE_THRESHOLD_BLOCKS else 0\n\n    processed_count = 0\n    for candidate in scored_candidates:\n        processed_count += 1\n        pubkey = candidate.get(\'pubkey\')\n        if not pubkey: continue # Should not happen if data is clean\n\n        # 1. Check blocklist\n        if pubkey in blocklist_set:\n            skipped_blocklist += 1\n            # print(f"  Discarding {pubkey[:10]}...: Blocklisted") # Debug\n            continue\n\n        # 2. Check if it\'s our own node\n        if pubkey == local_pubkey:\n            skipped_self += 1\n            # print(f"  Discarding {pubkey[:10]}...: Self") # Debug\n            continue\n\n        # 3. Check if already a peer (active channel)\n        if pubkey in current_peers:\n            skipped_current_peer += 1\n            # print(f"  Discarding {pubkey[:10]}...: Current Peer") # Debug\n            continue\n\n        # 4. Check for recent closures\n        closed_recently = False\n        for closure in recent_closures:\n            if closure.get(\'remote_pubkey\') == pubkey:\n                close_height = closure.get(\'close_height\', 0)\n                # Check if the closure happened after the cutoff height\n                if close_height > 0 and close_height >= closure_cutoff_height:\n                    closed_recently = True\n                    skipped_recent_closure += 1\n                    # print(f"  Discarding {pubkey[:10]}...: Recent Closure (Block {close_height})") # Debug\n                    break # No need to check other closures for this pubkey\n        if closed_recently:\n            continue\n\n        # 5. Optional: Check for recent failed *outgoing* open attempts (like FUNDING_CANCELED)\n        # Requires more detailed \'recent_closures\' data (initiator, close_type)\n        # failed_open_recently = False\n        # for closure in recent_closures:\n        #     if closure.get(\'remote_pubkey\') == pubkey and \\n        #        closure.get(\'close_type\') == \'FUNDING_CANCELED\' and \\ # Assuming type value\n        #        closure.get(\'open_initiator\') == \'INITIATOR_LOCAL\' and \\ # Assuming initiator value\n        #        closure.get(\'close_height\', 0) >= closure_cutoff_height: # Reuse cutoff\n        #             failed_open_recently = True\n        #             skipped_failed_open += 1\n        #             # print(f"  Discarding {pubkey[:10]}...: Recent Failed Open Attempt") # Debug\n        #             break\n        # if failed_open_recently:\n        #     continue\n\n        # 6. Optional: Check for shared peers\n        # Requires candidate\'s peers, which might involve another graph lookup or richer data.\n        # num_shared_peers = 0\n        # candidate_peers = get_peers_for_candidate(pubkey, graph_data) # Needs implementation\n        # if candidate_peers:\n        #      shared = current_peers.intersection(candidate_peers)\n        #      num_shared_peers = len(shared)\n        #      # Example threshold: discard if > 20% overlap\n        #      if len(current_peers) > 0 and (num_shared_peers / len(current_peers)) > 0.20:\n        #           skipped_shared_peers += 1\n        #           # print(f"  Discarding {pubkey[:10]}...: High Peer Overlap ({num_shared_peers})") # Debug\n        #           continue\n\n        # --- Candidate passed all filters ---\n        final_candidates.append(candidate)\n\n    end_time = time.time()\n    print(f"Final filtering finished in {end_time - start_time:.2f}s.")\n    print(f"  Candidates remaining: {len(final_candidates)}/{len(scored_candidates)}")\n    print(f"  Skipped (Blocklist): {skipped_blocklist}")\n    print(f"  Skipped (Self): {skipped_self}")\n    print(f"  Skipped (Current Peer): {skipped_current_peer}")\n    print(f"  Skipped (Recent Closure): {skipped_recent_closure}")\n    # Add counts for optional filters if implemented\n\n    return final_candidates\n\n# Example Local Node Info (would come from LNBits later)\nEXAMPLE_LOCAL_INFO = {\n    "pubkey": "LOCAL_NODE_PUBKEY",\n    "current_peers": {"B", "EXISTING_PEER"},\n    "recent_closures": [\n        {"remote_pubkey": "CLOSED_RECENTLY", "close_height": 800000, "close_type": "COOPERATIVE_CLOSE"},\n        {"remote_pubkey": "CLOSED_LONG_AGO", "close_height": 700000, "close_type": "COOPERATIVE_CLOSE"},\n        {"remote_pubkey": "FAILED_OPEN", "close_height": 810000, "close_type": "FUNDING_CANCELED", "open_initiator": "INITIATOR_LOCAL"},\n    ]\n}\nEXAMPLE_CURRENT_HEIGHT = 815000 # Example height\n\n# Example Usage (for testing)\nif __name__ == \'__main__\':\n    # Sample scored candidates (already sorted)\n    sample_scored_nodes = [\n        {\'pubkey\': \'A\', \'score\': 0.95, \'channels\': []},\n        {\'pubkey\': \'B\', \'score\': 0.90, \'channels\': []}, # Should be skipped (current peer)\n        {\'pubkey\': \'C\', \'score\': 0.88, \'channels\': []},\n        {\'pubkey\': \'CLOSED_RECENTLY\', \'score\': 0.85, \'channels\': []}, # Should be skipped\n        {\'pubkey\': \'BLOCKLISTED_NODE\', \'score\': 0.82, \'channels\': []},\n        {\'pubkey\': \'LOCAL_NODE_PUBKEY\', \'score\': 0.80, \'channels\': []}, # Should be skipped\n        {\'pubkey\': \'D\', \'score\': 0.75, \'channels\': []},\n        {\'pubkey\': \'CLOSED_LONG_AGO\', \'score\': 0.70, \'channels\': []}, # Should NOT be skipped\n        {\'pubkey\': \'FAILED_OPEN\', \'score\': 0.65, \'channels\': []}, # Would be skipped if failed open logic enabled\n    ]\n    sample_blocklist = ["BLOCKLISTED_NODE", "ANOTHER_BLOCKED"]\n\n    print("--- Running Example ---")\n    final_list = filter_candidates(\n        sample_scored_nodes,\n        EXAMPLE_LOCAL_INFO,\n        sample_blocklist,\n        EXAMPLE_CURRENT_HEIGHT\n    )\n\n    print("\n--- Final Candidate List ---")\n    if final_list:\n        for node in final_list:\n            print(f"  Pubkey: {node[\'pubkey\']}, Score: {node[\'score\']}")\n    else:\n        print("  No candidates passed final filtering.")\n 